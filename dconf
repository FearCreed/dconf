#!/usr/bin/python2

import os, sys, glob, re, shutil, getopt, popen2, time
import ConfigParser, urlparse, pwd, grp, stat
import difflib, smtplib, gzip

VERSION = "0.3"

enable = ('yes', 'on', 'true', '1')
disable = ('no', 'off', 'false', '0')

class Options:
	def __init__(self, args):
		self.configfile = '/etc/dconf.conf'
		self.dist = None
		self.output = None
		self.quiet = False
		self.verbose = 1

		try:
			opts, args = getopt.getopt (args, 'c:ho:qv',
				['config=', 'help', 'output=', 'quiet', 'verbose', 'version'])
		except getopt.error, exc:
			print 'dconf: %s, try dconf -h for a list of all the options' % str(exc)
			sys.exit(1)

		for opt, arg in opts:
			if opt in ['-c', '--config']:
				self.configfile = os.path.abspath(arg)
			elif opt in ['-h', '--help']:
				self.usage()
				self.help()
				sys.exit(0)
			elif opt in ('-o', '--output'):
				self.output=arg
			elif opt in ['-q', '--quiet']:
				self.quiet = True
			elif opt in ['-v', '--verbose']:
				self.verbose = self.verbose + 1
			elif opt in ['--version']:
				self.version()
				sys.exit(0)

		if self.quiet:
			self.verbose = 0

		if self.verbose >= 3:
			print 'Verbosity set to level %d' % (self.verbose - 1)
			print 'Using configfile %s' % self.configfile

	def version(self):
		print 'dconf %s' % VERSION
		print 'Written by Dag Wieers <dag@wieers.com>'
		print
		print 'platform %s/%s' % (os.name, sys.platform)
		print 'python %s' % sys.version

	def usage(self):
		print 'usage: dconf [-q] [-v] [-c config] [-o output]'

	def help(self):
		print '''Collect a system's hardware and software configuration

Dconf options:
  -c, --config=file     specify alternative configfile
  -o, --output=file		write output to given file
  -q, --quiet           minimal output
  -v, --verbose         increase verbosity
  -vv, -vvv             increase verbosity more
'''

class Config:
	def __init__(self):
		self.sections = {}

		self.includefile(op.configfile)
		self.include = self.getoption('main', 'include', None)

	def includefile(self, configfile):
		self.cfg = ConfigParser.ConfigParser()

		(s,b,p,q,f,o) = urlparse.urlparse(configfile)
		if s in ('http', 'ftp', 'file'):
			configfh = urllib.urlopen(configfile)
			try:
				self.cfg.readfp(configfh)
			except ConfigParser.MissingSectionHeaderError, e:
				die(6, 'Error accessing URL: %s' % configfile)
		else:
			if os.access(configfile, os.R_OK):
				try:
					self.cfg.read(configfile)
				except:
					die(7, 'Syntax error reading file: %s' % configfile)
			else:
				die(6, 'Error accessing file: %s' % configfile)

		self.compression = self.getoption('main', 'compression', 'gzip')
		self.cron = self.getoption('main', 'cron', None)
		self.logdir = self.getoption('main', 'logdir', '/var/log/dconf')
		self.mailto = self.getoption('main', 'mailto', None)
		self.smtpserver = self.getoption('main', 'smtp-server', 'localhost')
		self.rpm = not self.getoption('main', 'rpm', 'no') in disable

		if not op.output:
			op.output = self.getoption('main', 'output', None)

		self.quiet = not self.getoption('main', 'quiet', 'no') in disable
		if op.verbose == 1 and self.quiet:
			op.verbose = 0


		sections = self.cfg.sections()
		sections.sort()
		for section in sections:
			if section in ['main']:
				continue
			else:
				self.sections[section] = {}
				for option in self.cfg.options(section):
					if option in ('cmds', 'dirs', 'files'):
						self.sections[section][option] = self.getoption(section, option, '').split('\n')

	def getoption(self, section, option, var):
		"Get an option from a section from configfile"
		try:
			var = self.cfg.get(section, option)
#			info(3, 'Setting option %s in section [%s] to: %s' % (option, section, var))
		except ConfigParser.NoSectionError, e:
#			info(4, 'Failed to find section [%s] in %s' % (section, op.configfile))
			pass
		except ConfigParser.NoOptionError, e:
#			info(4, 'Setting option %s in section [%s] to: %s (default)' % (option, section, var))
			pass
		return var

def info(level, str):
	"Output info message"
	if level <= op.verbose:
		print str

def die(ret, str):
	"Print error and exit with errorcode"
	info(0, str)
	sys.exit(ret)

def cleanup():
	"Clean up logfile when interrupted."
	logfile = os.path.join(cf.logdir, 'dconf-' + hostname + '-' + timestamp + '.log' + extension)
	if os.path.isfile(logfile):
		remove(logfile)

def symlink(src, dst):
	"Create a symbolic link, force if dst exists"
	if not os.path.islink(dst) and os.path.isdir(dst):
		dst = os.path.join(dst, os.path.basename(src))
### Not using filecmp increases speed with 15%
#	if os.path.isfile(dst) and filecmp.cmp(src, dst) == 0:
	if os.path.isfile(dst):
		os.unlink(dst)
	if os.path.islink(dst):
		os.unlink(dst)
	mkdir(os.path.dirname(dst))
	if not os.path.exists(dst):
		os.symlink(src, dst)

def remove(*files):
	"Remove files or directories"
	for file in files:
		if os.path.islink(file):
			os.unlink(file)
		elif os.path.isdir(file):
			try:
				os.rmdir(file)
			except:
				os.path.walk(file, removedir, ())
		elif os.path.exists(file):
			os.unlink(file)

def removedir(void, dir, files):
	for file in files:
		remove(os.path.join(dir, file))

def mkdir(path):
	"Create a directory, and parents if needed"
	if not os.path.exists(path):
		os.makedirs(path)

def which(cmd):
	"Find executables in PATH environment"
	for path in os.environ.get('PATH','$PATH').split(':'):
		if os.path.isfile(os.path.join(path, cmd)):
			info(4, 'Found command %s in path %s' % (cmd, path))
			return os.path.join(path, cmd)
	return ''

def diff(fromfile, tofile):
	msg = ''
#	fromfd = file(fromfile)
#	tofd = file(tofile)
	fromfd = open(fromfile)
	tofd = open(tofile)
	for line in difflib.unified_diff(fromfd.readlines(), tofd.readlines(), fromfile, tofile, os.stat(fromfile).st_mtime, os.stat(tofile).st_mtime):
		msg = msg + line
	tofd.close()
	fromfd.close()
	return msg

def mail(subject, msg):
	info(2, 'Sending mail to: %s' % cf.mailto)
	smtp = smtplib.SMTP(cf.smtpserver)
#	server.set_debuglevel(1)
	for email in cf.mailto.split():
		msg = 'To: %s\n' % email + \
			'Subject: %s\n\n' % subject + '\n' + \
			'Current time:\n' + os.popen('date').read() + '\n' + \
			'System information:\n'+ os.popen('uname -a').read() + '\n' + \
			'Uptime:\n' + os.popen('uptime').read() + '\n' + \
			'Currently logged on users:\n' + os.popen('who').read() + '\n' + \
			subject + '\n\n' + msg
		smtp.sendmail('dconf@%s' % os.uname()[1], email, msg)
	smtp.quit()

def main():
	os.umask(077)

	### Add to cron
	if cf.cron and not op.output:
		if cf.cron in ('hourly', 'daily', 'weekly', 'monthly'):
			cronfile = os.path.join('/etc', 'cron.%s' % cf.cron, 'dconf')
			if os.path.isdir(os.path.dirname(cronfile)):
				if (os.path.realpath(cronfile) != which('dconf')):
					info(2, 'Adding dconf to cron (%s).' % cf.cron)
					symlink(which('dconf'), cronfile)
			else:
				info(2, 'Path %s does not exist, ignoring.' % os.path.dirname(cronfile))
		else:
			info(2, 'Option cron should be set to hourly, daily, weekly or monthly.')

	### Remove from cron
	for item in ('hourly', 'daily', 'weekly', 'monthly'):
		if item != cf.cron:
			cronfile = os.path.join('/etc', 'cron.%s' % item, 'dconf')
			if os.path.isfile(cronfile):
				info(2, 'Removing dconf from cron (%s).' % item)
				remove(cronfile)

	if op.output == '-':
		logfile = '- (stdout)'
		log = sys.stdout
		op.quiet = True
		op.verbose = 0
	else:
		if op.output:
			logfile = op.output
   			log = open(logfile, 'w')
		else:
			logfile = os.path.join(cf.logdir, 'dconf-' + hostname + '-' + timestamp + '.log' + extension)
			mkdir(cf.logdir)
			os.chmod(cf.logdir, 0700)
#  			log = open(logfile, 'w')
			log = open(logfile, 'w')
			latestlog = os.path.join(cf.logdir, 'dconf-' + hostname + '-latest.log' + extension)
			previouslog = os.path.join(cf.logdir, 'dconf-' + hostname + '-previous.log' + extension)
			oldestlog = os.path.join(cf.logdir, 'dconf-' + hostname + '-oldest.log' + extension)


	info(2, 'Building file: %s' % logfile)
	for section in cf.sections:
		stitle = None

		if cf.sections[section].has_key('cmds'):
			for line in cf.sections[section]['cmds']:
				clist = line.split()
				if clist:
					cmd = clist[0].strip()
					cmd = which(cmd)
					extra = ' '.join(clist[1:])
					if cmd:
						(mode, t, t, t, uid, gid, size, t, t, t) = os.stat(cmd)
						info(4, 'Processing cmd %s' % cmd)
						try: owner = pwd.getpwuid(uid)
						except: owner = (uid)
						try: group = grp.getgrgid(gid)
						except: group = (gid)
						if not stitle:
							info(3, 'Processing section [%s]' % section)
							stitle = '== ' + section.upper() + ' =='
							log.write(stitle + '=' * (80 - len(stitle)) + '\n')
						title = '--[ Cmd: %s %s ]--(%04o, %s, %s, %s)--' % (cmd, extra, stat.S_IMODE(mode), owner[0], group[0], size)
						log.write(title + '-' * (80 - len(title)) + '\n')
						(o, i) = popen2.popen4('%s %s' % (cmd, extra))
						log.write(o.read())
						log.write('\n')

		if cf.sections[section].has_key('files'):
			for line in cf.sections[section]['files']:
				flist = line.split('|')
				if flist:
					extra = '|'.join(flist[1:])
					if extra: extra = extra + ' '
					for file in glob.glob(flist[0].strip()):
						if file and os.path.isfile(file):
							(mode, t, t, t, uid, gid, size, t, t, t) = os.stat(file)
							if not size: continue
#							if cf.rpm:
#								if not os.system('rpm --quiet --nodigest --nosignature -qf %s' % file):
#									if os.system('rpm --nodigest --nosignature -Vf %s | grep -q -E "^(S..|.M.|..5)..... c %s\$"' % (file, file)):
#										info(4, 'File %s has not been changed since installation.' % file)
#										continue
#									else:
#										info(1, 'YES!!! File %s _has_ been changed since installation.' % file)
							info(4, 'Processing file %s' % file)
							try: owner = pwd.getpwuid(uid)
							except: owner = (uid)
							try: group = grp.getgrgid(gid)
							except: group = (gid)
							if not stitle:
								info(3, 'Processing section [%s]' % section)
								stitle = '== ' + section.upper() + ' =='
								log.write(stitle + '=' * (80 - len(stitle)) + '\n')
							title = '--[ File: %s %s]--(%04o, %s, %s, %s)--' % (file, extra, stat.S_IMODE(mode), owner[0], group[0], size)
							log.write(title + '-' * (80 - len(title)) + '\n')
							(o, i) = popen2.popen4('cat %s %s' % (file, extra))
							log.write(o.read())
							log.write('\n')
	log.close()

	if op.output:
		return

	if os.path.isfile(latestlog):
		import md5
		md5old = md5.new(); file = open(latestlog, 'r'); md5old.update(file.read()); file.close()
		md5new = md5.new(); file = open(logfile, 'r'); md5new.update(file.read()); file.close()

		if md5old.digest() != md5new.digest():
			info(2, 'New logfile is different than last logfile, keeping.')
			symlink(os.path.realpath(latestlog), previouslog)
			symlink(logfile, latestlog)
			if cf.mailto:
				mail('changes to %s' % os.uname()[1], diff(os.path.realpath(previouslog), os.path.realpath(latestlog)))
		else:
			info(2, 'New logfile is identical to last logfile, removing.')
			remove(logfile)
	else:
		info(2, 'Marking this as a first time run, symlinking.')
		symlink(logfile, oldestlog)
		symlink(logfile, previouslog)
		symlink(logfile, latestlog)
		if cf.mailto:
			mail('initial config for %s' % os.uname()[1], open(logfile, 'r').read())

### Workaround for python <= 2.2.1
try:
     True, False
except NameError:
     True = 1
     False = 0
Yes = yes = On = on = True
No = no = Off = off = False

### Main entrance
if __name__ == '__main__':
	op=Options(sys.argv[1:])
	cf=Config()
	for cfgfile in cf.include.split():
		if os.path.isfile(cfgfile):
			info(2, 'Processing configfile %s.' % cfgfile)
			cf.includefile(cfgfile)
		else:
			info(3, 'Configfile %s does not exist, ignoring.')

	extension = ''
	if cf.compression == 'bzip2':
		from bz2 import BZ2File as open
		extension = '.bz2'
	elif cf.compression == 'gzip':
		from gzip import open
		extension = '.gz'

	hostname = os.uname()[1].split('.')[0]
	timestamp = time.strftime('%Y%m%d-%H%M%S', time.localtime()) 

	try:
		main()
	except KeyboardInterrupt, e:
		cleanup()
		die(6, 'Exiting on user request')
	except OSError, e:
#		print e.errno
		cleanup()
		die(7, 'OSError: %s' % e)

# vim:ts=4:sw=4
